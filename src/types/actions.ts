/**
 * アクション*は、状態を変更する意図を表すプレーンなオブジェクトです。
 * 状態を変更する意図を表すプレーンなオブジェクトです。アクションは、データをストアに入れる唯一の方法です。どんなデータでも
 * UIイベント、ネットワークコールバック、またはWebSocketのような他のソースからのデータは、最終的にアクションとしてディスパッチされる必要があります。
 * WebSocketからのデータは、最終的にアクションとしてディスパッチされる必要があります。
 *
 * アクションには、実行されるアクションのタイプを示す `type` フィールドが必要です。
 * アクションには、実行されるアクションのタイプを示す `type` フィールドが必要です。タイプは定数として定義し、他のモジュールからインポートすることができます。
 * モジュールからインポートすることができます。type` にはシンボルよりも文字列を使ったほうがいいでしょう。
 * 文字列はシリアライズ可能です。
 *
 * `type` 以外のアクションオブジェクトの構造は、あなた次第です。
 * 興味のある方は、Flux Standard Actionをチェックしてみてください。
 * アクションをどのように構築すべきかについての推奨事項です。
 *
 * @template T アクションの `type` タグのタイプを指定します。
 */

export interface Action<T = any> {
  type: T
}

/**
 * 任意の他のプロパティを受け入れる Action タイプです。
 * これは主に `Reducer` タイプを使用するためのものです。
 * これは、`Action` を拡張した型がインデックス署名を持つことを防ぐために、`Action` 自身の一部ではありません。
 * インデックスシグネチャを持つ。
 */

export interface AnyAction extends Action {
  // Allows any extra properties to be defined in an action.
  [extraProps: string]: any
}

/* action creators */

/**
 *アクションクリエイター*とは、簡単に言えば、アクションを作成する関数です。この2つの用語を混同しないでください。
 * この2つの用語を混同しないでください。
 * アクションクリエイターとは、アクションを作成するファクトリーのことです。
 *
 * アクションクリエイターを呼び出しても、アクションを生成するだけで、ディスパッチはしません。
 * しません。実際に変異を起こすには、ストアの `dispatch` 関数を呼び出す必要があります。
 * 変異させる必要があります。アクションクリエータを呼び出すと、すぐにアクションを実行することができます。
 アクションクリエイターを呼び出し、その結果を特定のストアインスタンスに即座にディスパッチする関数を意味して、 *バウンドアクショニスト* と呼ぶことがあります。
 * ストアのインスタンスにディスパッチする関数を意味します。
 *
 * アクションクリエイターが現在の状態を読み取ったり、APIコールを実行したりする必要がある場合。
 * アクションクリエイターが現在の状態を読み取ったり、APIコールを実行したり、ルーティングトランジションのような副作用を引き起こす必要がある場合は、非同期アクションを返す必要があります。
 * アクションの代わりに非同期アクションを返す必要があります。
 *
 * @template A 返されるアクションタイプ。
 */

export interface ActionCreator<A, P extends any[] = any[]> {
  (...args: P): A
}

/**
 * アクションクリエイター関数を値とするオブジェクト。
 */
export interface ActionCreatorsMapObject<A = any, P extends any[] = any[]> {
  [key: string]: ActionCreator<A, P>
}
